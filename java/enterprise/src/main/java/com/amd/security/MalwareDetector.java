// java/enterprise/src/main/java/com/amd/security/MalwareDetector.java
package com.amd.security;

import java.util.*;

/**
 * Malware Detection System
 * Detects suspicious code patterns and malicious scripts
 */
public class MalwareDetector {
    
    private static final float CONFIDENCE_THRESHOLD = 0.75f;
    private final Set<String> suspiciousFunctions;
    private final Set<String> obfuscationIndicators;
    
    public MalwareDetector() {
        this.suspiciousFunctions = new HashSet<>(Arrays.asList(
            "eval", "exec", "system", "shell_exec", "passthru"
        ));
        this.obfuscationIndicators = new HashSet<>(Arrays.asList(
            "atob", "btoa", "String.fromCharCode", "unescape"
        ));
    }
    
    /**
     * Detect malicious code patterns
     */
    public ThreatDetectionService.ThreatResult detect(String code) {
        if (code == null || code.isEmpty()) {
            return new ThreatDetectionService.ThreatResult(
                "malware", 0.0f, false, 
                Collections.singletonList("Empty content")
            );
        }
        
        float threatScore = calculateThreatScore(code);
        boolean isMalicious = threatScore >= CONFIDENCE_THRESHOLD;
        
        List<String> reasons = generateReasons(code);
        
        return new ThreatDetectionService.ThreatResult(
            "malware",
            Math.min(threatScore, 1.0f),
            isMalicious,
            reasons
        );
    }
    
    private float calculateThreatScore(String code) {
        float score = 0.0f;
        String codeLower = code.toLowerCase();
        
        // Detect suspicious functions
        for (String func : suspiciousFunctions) {
            if (codeLower.contains(func)) {
                score += 0.2f;
            }
        }
        
        // Detect obfuscation
        for (String indicator : obfuscationIndicators) {
            if (codeLower.contains(indicator.toLowerCase())) {
                score += 0.25f;
            }
        }
        
        // Detect script injection patterns
        if (code.contains("<script") || code.contains("onclick=")) {
            score += 0.3f;
        }
        
        return Math.min(score, 1.0f);
    }
    
    private List<String> generateReasons(String code) {
        List<String> reasons = new ArrayList<>();
        String codeLower = code.toLowerCase();
        
        if (codeLower.contains("eval")) {
            reasons.add("Contains dangerous eval() function");
        }
        if (codeLower.contains("atob") || codeLower.contains("btoa")) {
            reasons.add("Code obfuscation detected");
        }
        if (code.contains("<script") || code.contains("onclick")) {
            reasons.add("Script injection patterns found");
        }
        
        if (reasons.isEmpty()) {
            reasons.add("Code appears safe");
        }
        
        return reasons;
    }
}

/**
 * Behavior Analysis System
 * Monitors and analyzes system behavior for anomalies
 */
public class BehaviorAnalyzer {
    
    private static final float ANOMALY_THRESHOLD = 0.8f;
    private final Queue<SystemAction> actionHistory;
    private final int historySize;
    
    public BehaviorAnalyzer() {
        this.historySize = 100;
        this.actionHistory = new LinkedList<>();
    }
    
    /**
     * Analyze system action for anomalies
     */
    public ThreatDetectionService.ThreatResult analyze(Map<String, Object> actionData) {
        SystemAction action = parseAction(actionData);
        actionHistory.offer(action);
        
        // Keep history size limited
        if (actionHistory.size() > historySize) {
            actionHistory.poll();
        }
        
        float anomalyScore = calculateAnomalyScore(action);
        boolean isAnomaly = anomalyScore >= ANOMALY_THRESHOLD;
        
        List<String> reasons = generateAnomalyReasons(action, anomalyScore);
        
        return new ThreatDetectionService.ThreatResult(
            "behavioral",
            Math.min(anomalyScore, 1.0f),
            isAnomaly,
            reasons
        );
    }
    
    private SystemAction parseAction(Map<String, Object> data) {
        return new SystemAction(
            (String) data.getOrDefault("type", "unknown"),
            (Map<String, Object>) data.getOrDefault("details", new HashMap<>()),
            System.currentTimeMillis()
        );
    }
    
    private float calculateAnomalyScore(SystemAction action) {
        float score = 0.0f;
        
        // Evaluate action risk
        if ("registry".equals(action.type) || "process".equals(action.type)) {
            score += 0.4f;
        }
        
        // Evaluate pattern anomalies
        if (actionHistory.size() > 5) {
            long recentActions = actionHistory.stream()
                .filter(a -> System.currentTimeMillis() - a.timestamp < 1000)
                .count();
            
            if (recentActions > 5) {
                score += 0.3f;  // Rapid succession of actions
            }
        }
        
        return Math.min(score, 1.0f);
    }
    
    private List<String> generateAnomalyReasons(SystemAction action, float score) {
        List<String> reasons = new ArrayList<>();
        
        if (score > 0.5f && ("registry".equals(action.type) || "process".equals(action.type))) {
            reasons.add("Suspicious " + action.type + " action");
        }
        
        if (reasons.isEmpty()) {
            reasons.add("Action appears normal");
        }
        
        return reasons;
    }
    
    // Inner class for system actions
    private static class SystemAction {
        String type;
        Map<String, Object> details;
        long timestamp;
        
        SystemAction(String type, Map<String, Object> details, long timestamp) {
            this.type = type;
            this.details = details;
            this.timestamp = timestamp;
        }
    }
}
